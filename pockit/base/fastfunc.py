# Copyright (c) 2024 Yilin Zou
import functools
import os
import tempfile
import importlib.util
import sys
from typing import Callable, Optional
from pathlib import Path

import numpy as np
import sympy as sp
from sympy.codegen.rewriting import create_expand_pow_optimization
from sympy.printing.lambdarepr import lambdarepr

from .vectypes import *


@functools.lru_cache
def _deco_F(fastmath: bool, cache: bool) -> str:
    """Decorator for the aggregate function F (value)."""
    tail = ""
    if fastmath:
        tail += ", fastmath=True"
    if cache:
        tail += ", cache=True"
    return '@numba.njit("float64[:](float64[:], int32)"{})\n'.format(tail)


@functools.lru_cache
def _deco_GH(fastmath: bool, cache: bool) -> str:
    """Decorator for the aggregate functions G (gradient) and H (hessian)."""
    tail = ""
    if fastmath:
        tail += ", fastmath=True"
    if cache:
        tail += ", cache=True"
    return '@numba.njit("float64[:, :](float64[:], int32)"{})\n'.format(tail)


def _code_basic(expr: sp.Expr, opt) -> str:
    """Generate code for a basic function."""
    return lambdarepr(opt(expr)).replace("math.", "")


def _load_module(path: str):
    """Load a module from a file."""
    spec = importlib.util.spec_from_file_location("module", path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[spec.name] = module
    spec.loader.exec_module(module)
    return module


def _fnv1a_hash(text: str) -> int:
    """Compute FNV-1a hash of a string."""
    # FNV-1a hash parameters
    FNV_PRIME = 0x01000193
    FNV_OFFSET_BASIS = 0x811C9DC5

    # Convert string to bytes using UTF-8 encoding
    byte_array = text.encode("utf-8")

    # Compute hash
    hash_value = FNV_OFFSET_BASIS
    for byte in byte_array:
        hash_value ^= byte
        hash_value = (hash_value * FNV_PRIME) & 0xFFFFFFFF

    return hash_value


class FastFunc:
    """JITed, vectorized functions with automatic differentiation to compute
    value, gradient, and hessian.

    FastFunc takes a Sympy expression and a list of Sympy symbols as
    function arguments, generates JITed, vectorized functions for value,
    gradient, and hessian. Gradient and hessian are generated by
    automatic differentiation and in sparse format, i.e., only non-zero
    elements are computed.
    """

    F: Callable[[VecFloat, np.int32], VecFloat]
    """Vectorized function to compute value."""
    G: Callable[[VecFloat, np.int32], VecFloat]
    """Vectorized function to compute gradient."""
    H: Callable[[VecFloat, np.int32], VecFloat]
    """Vectorized function to compute hessian."""
    G_index: VecInt
    """Indices of non-zero elements for gradient."""
    H_index_row: VecInt
    """Row indices of non-zero elements in the lower triangular part of the Hessian."""
    H_index_col: VecInt
    """Column indices of non-zero elements in the lower triangular part of the Hessian."""

    def __init__(
        self,
        function: int | float | sp.Expr,
        args: list[sp.Symbol],
        simplify: bool = False,
        fastmath: bool = False,
        *,
        cache: Optional[str] = None,
    ) -> None:
        """Suppose the expression of the input function is ``f(a_1, a_2, ..., a_n)``, with ``n`` arguments
        ``(a_1, a_2, ..., a_n)`` as the second argument ``args``. The generated functions ``F``, ``G``, and ``H``
        take two arguments ``x`` and ``k``, where ``x`` is a 1D array of length ``n * k``, and ``k`` is an integer.
        The first ``n`` elements of ``x`` are the values of ``a_1`` at ``k`` different points, the next ``n`` elements are
        the values of ``a_2``, and so on. The return value of ``F`` is a 1D array of length ``k``, where the ``i``-th
        element is the value of ``f(a_1, a_2, ..., a_n)`` at the ``i``-th point. The return value of ``G`` is a 2D array
        of shape ``(len(G_index), k)``, where ``G_index`` contains the indices of non-zero elements in the gradient matrix.
        The return value of ``H`` is a 2D array of shape ``(len(H_index_row), k)``, where ``H_index_row, H_index_col``
        contain the indices of non-zero elements in the lower triangular part of the hessian matrix.

        If ``simplify`` is ``True``, every symbolic expression will be simplified (by :func:`sympy.simplify`) before
        being compiled. This will slow down the compilation speed.

        If ``fastmath`` is ``True``, the ``fastmath`` flag will be passed to the Numba JIT compiler.
        See [Numba](https://numba.pydata.org/numba-doc/latest/user/performance-tips.html#fastmath)
        and [LLVM](https://llvm.org/docs/LangRef.html#fast-math-flags) documentation for details.

        If ``cache`` is a path to a file, the FastFunc object will do the following: 1. If the file does not exist, the generated
        functions will be written to the file so they can be loaded later. 2. If the file exists and there is a hash
        string at the beginning of the file (auto-generated by FastFunc), the hash will be compared with the hash of the
        current function to determine whether to load the file directly or overwrite it. 3. If the file exists and there
        is no hash string at the beginning of the file, the file is considered a user-provided file and will be loaded
        directly.

        Args:
            function: :class:`Sympy.Expr` of the function.
            args: :class:`sympy.Symbol` s of the function arguments.
            simplify: Whether to use :func:`Sympy.simplify` to simplify expressions before compilation.
            fastmath: Whether to use Numba ``fastmath`` mode.
            cache: Path to a file to cache the generated functions.
        """
        self._function = sp.sympify(function)
        self._args = args

        # random valid Python name to avoid conflict
        self._valid_args = [
            sp.Symbol("xbN4dRhrnN{}".format(i)) for i in range(len(args))
        ]
        for i in range(len(args)):
            self._function = self._function.subs(args[i], self._valid_args[i])
        self._args = self._valid_args

        self._hash = "# hash {}\n".format(
            _fnv1a_hash(str(self._function) + str(len(self._args)))
        )

        if cache is not None and os.path.isfile(cache):
            with open(cache, "r") as file:
                hash_file = file.readline()
                if hash_file == self._hash:
                    # The file is auto-generated and matches the current function
                    self._load(cache)
                    return
                elif not hash_file.startswith("# hash"):
                    # The file is not auto-generated (no hash found)
                    # Load the user-provided file directly
                    self._load(cache)
                    return

        self._simplify = simplify
        self._fastmath = fastmath
        self._cache = cache

        self._expr_value = 0
        self._expr_grad = []
        self._index_grad = []
        self._expr_hess = []
        self._index_hess = []

        self._gen_basic_funcs()

        self.__expand_opt = create_expand_pow_optimization(3)

        code = self._gen_aggregate_funcs()
        self.G_index = self._gen_G_index()
        self.H_index_row, self.H_index_col = self._gen_H_index()
        self._compile(code, cache)

    def _load(self, cache: str) -> None:
        module = _load_module(cache)
        self.F = module.F
        self.G = module.G
        self.H = module.H
        self.G_index = module.G_index
        self.H_index_row = module.H_index_row
        self.H_index_col = module.H_index_col

    def _compile(self, code: str, cache: Optional[str]) -> None:
        if cache is not None:
            path = cache
            file = open(path, "w")
            file.write(self._hash)
        else:
            file = tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False)
            path = file.name
        file.write("from numpy import *\n")
        file.write("import numba\n\n")
        file.write(code)
        if cache is not None:
            file.write(
                "G_index = array([{}], dtype=int32)\n".format(
                    ", ".join(map(str, self.G_index))
                )
            )
            file.write(
                "H_index_row = array([{}], dtype=int32)\n".format(
                    ", ".join(map(str, self.H_index_row))
                )
            )
            file.write(
                "H_index_col = array([{}], dtype=int32)\n".format(
                    ", ".join(map(str, self.H_index_col))
                )
            )
        file.close()

        module = _load_module(path)

        self.F = module.F
        self.G = module.G
        self.H = module.H

        if cache is None:
            os.unlink(path)

    def _free_symbols(self, expr: sp.Expr) -> list[int]:
        return sorted([self._args.index(sym) for sym in expr.free_symbols])

    def _gen_basic_funcs(self):
        func = self._function

        # value
        if self._simplify:
            func = sp.simplify(func)
        self._expr_value = func

        free_symbols_value = self._free_symbols(func)

        for j in free_symbols_value:  # row of hessian
            # gradient
            grad = sp.diff(func, self._args[j])
            if self._simplify:
                grad = sp.simplify(grad)
            if grad == 0:
                continue
            self._expr_grad.append(grad)
            self._index_grad.append(j)

            free_symbols_grad = self._free_symbols(grad)

            # hessian
            for k in free_symbols_grad:  # col of hessian
                if j < k:
                    break
                hess = sp.diff(grad, self._args[k])
                if self._simplify:
                    hess = sp.simplify(hess)
                if hess == 0:
                    continue
                self._expr_hess.append(hess)
                self._index_hess.append((j, k))

    def _gen_code_F(self, expr) -> str:
        deco = _deco_F(self._fastmath, self._cache is not None)
        head = "def F(x, n):\n"
        body = "    r = empty(n, dtype=float64)\n"
        common_expr = sp.cse(
            expr, optimizations="basic", symbols=sp.numbered_symbols("ce")
        )
        for cse_symbol, cse_expr in common_expr[0]:
            body += f"    {cse_symbol} = {_code_basic(cse_expr, self.__expand_opt)}\n"
        body += f"    r[:] = {_code_basic(common_expr[1][0], self.__expand_opt)}\n"
        body += "    return r\n\n"
        return deco + head + body

    def _gen_code_GH(self, name, exprs) -> str:
        deco = _deco_GH(self._fastmath, self._cache is not None)
        head = f"def {name}(x, n):\n"
        body = f"    r = empty(({len(exprs)}, n), dtype=float64)\n"
        expr_common = sp.cse(
            exprs, optimizations="basic", symbols=sp.numbered_symbols("ce")
        )
        for cse_symbol, cse_expr in expr_common[0]:
            body += f"    {cse_symbol} = {_code_basic(cse_expr, self.__expand_opt)}\n"
        for row, expr in enumerate(expr_common[1]):
            body += f"    r[{row}] = {_code_basic(expr, self.__expand_opt)}\n"
        body += "    return r\n\n"
        return deco + head + body

    def _gen_aggregate_funcs(self) -> str:
        code = (
            self._gen_code_F(self._expr_value)
            + self._gen_code_GH("G", self._expr_grad)
            + self._gen_code_GH("H", self._expr_hess)
        )

        for i in range(len(self._args) - 1, -1, -1):
            code = code.replace(f"xbN4dRhrnN{i}", f"x[{i}*n:{i + 1}*n]")

        return code

    def _gen_G_index(self) -> VecInt:
        return np.array(self._index_grad, dtype=np.int32)

    def _gen_H_index(self) -> tuple[VecInt, VecInt]:
        return (
            np.array([x for x, _ in self._index_hess], dtype=np.int32),
            np.array([y for _, y in self._index_hess], dtype=np.int32),
        )


def ensure_directory(path: str | Path):
    """
    Ensure that the path exists and is a directory.

    Args:
        path: The path to check/create (can be a string or a Path object).
    """
    path = Path(path) if not isinstance(path, Path) else path

    # If the path exists
    if path.exists():
        # Check if it is a directory
        if not path.is_dir():
            raise NotADirectoryError(f"Path {path} exists but is not a directory")
    else:
        # Create the directory (including all necessary parent directories)
        path.mkdir(parents=True, exist_ok=True)
